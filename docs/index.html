<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Horizon – A Modern Web Framework for Zig</title>
  <meta name="description" content="Horizon is a modern, fast, and extensible web framework for Zig. Learn how to build HTTP APIs, middleware, sessions, and templates with Horizon." />
  <link rel="stylesheet" href="styles.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
</head>
<body>
  <div class="page">
    <header class="site-header">
      <a href="#overview" class="logo">
        <img src="horizon_logo.png" alt="Horizon logo" class="logo-img" />
      </a>
      <nav class="top-nav">
        <a href="#overview">Overview</a>
        <a href="#getting-started">Getting Started</a>
        <a href="#routing">Routing</a>
        <a href="#middleware">Middleware</a>
        <a href="#sessions">Sessions</a>
        <a href="#templates">Templates</a>
        <a href="#sample-app">Sample App</a>
      </nav>
      <a class="top-cta" href="https://github.com/HARMONICOM/horizon" target="_blank" rel="noreferrer">GitHub</a>
    </header>

    <div class="layout">
      <aside class="sidebar">
        <div class="sidebar-section">
          <div class="sidebar-title">Introduction</div>
          <a href="#overview">What is Horizon?</a>
          <a href="#features">Key Features</a>
          <a href="#requirements">Requirements</a>
        </div>
        <div class="sidebar-section">
          <div class="sidebar-title">Guides</div>
          <a href="#getting-started">Getting Started</a>
          <a href="#routing">Routing</a>
          <a href="#request-response">Request &amp; Response</a>
          <a href="#middleware">Middleware</a>
          <a href="#sessions">Sessions</a>
          <a href="#templates">Templates</a>
        </div>
        <div class="sidebar-section">
          <div class="sidebar-title">Reference</div>
          <a href="#api-reference">High-level API</a>
          <a href="#project-structure">Project Structure</a>
          <a href="#testing">Testing</a>
        </div>
        <div class="sidebar-section">
          <div class="sidebar-title">Example</div>
          <a href="#sample-app">Sample Application</a>
        </div>
      </aside>

      <main class="content">
        <section class="hero">
          <p class="hero-eyebrow">Web framework for Zig</p>
          <h1>Build fast, type-safe web services with Horizon.</h1>
          <p class="hero-subtitle">
            Horizon is a modern web framework for Zig focused on simplicity, performance, and extensibility.
            It provides an HTTP server, routing, middleware, sessions, and template rendering – all with Zig’s
            strong compile-time guarantees.
          </p>
          <div class="hero-actions">
            <a class="btn primary" href="#getting-started">Get Started</a>
            <a class="btn ghost" href="#minimal-example">View Minimal Example</a>
          </div>
          <div class="hero-meta">
            <span>Requires Zig 0.15.2+</span>
            <span>PCRE2 for regex routing</span>
            <span>ZTS for templates</span>
          </div>
        </section>

        <section id="overview" class="doc-section">
          <h2>Overview</h2>
          <p>
            Horizon is a web framework written in Zig. It aims to keep the core small and predictable while giving
            you the tools you need to build HTTP APIs and web applications:
          </p>
          <ul>
            <li><strong>Simplicity</strong>: Straightforward APIs and clear control flow.</li>
            <li><strong>Performance</strong>: Built on Zig’s low-level control and optimizations.</li>
            <li><strong>Extensibility</strong>: Composable middleware chains and pluggable session backends.</li>
            <li><strong>Type safety</strong>: Strong compile-time guarantees backed by Zig’s type system.</li>
          </ul>

          <h3 id="features">Key Features</h3>
          <ul>
            <li><strong>HTTP Server</strong>: Lightweight server built on Zig’s standard library.</li>
            <li><strong>Routing</strong>: Method-based routing with path parameters and PCRE2-based regex constraints.</li>
            <li><strong>Request &amp; Response</strong>: Helpers for headers, query params, JSON/HTML/text responses, and file streaming.</li>
            <li><strong>Middleware</strong>: Global and route-specific middleware chains with built-in middlewares (logging, CORS, auth, error handling, static files).</li>
            <li><strong>Sessions</strong>: Cookie-based session management with memory and Redis backends.</li>
            <li><strong>Templates</strong>: ZTS (Zig Templates made Simple) integration for HTML rendering.</li>
          </ul>

          <h3 id="requirements">Requirements</h3>
          <ul>
            <li><strong>Zig</strong>: 0.15.2 or later.</li>
            <li><strong>PCRE2</strong> (`libpcre2-8`): For regex-based routing.</li>
            <li><strong>ZTS</strong> (Zig Template Strings): For server-side HTML templates.</li>
            <li><strong>Docker &amp; Docker Compose</strong> (optional): For a preconfigured development environment.</li>
          </ul>
        </section>

        <section id="getting-started" class="doc-section">
          <h2>Getting Started</h2>
          <p>
            This quickstart shows how to set up Horizon as a dependency and run a minimal HTTP server.
            For a fully configured example including frontend and database, see the sample application below.
          </p>

          <h3>1. Add Horizon as a dependency</h3>
          <p>Fetch Horizon using Zig’s package manager:</p>
          <pre><code class="code-block">zig fetch --save-exact=horizon https://github.com/HARMONICOM/horizon/archive/refs/tags/0.1.2.tar.gz</code></pre>

          <h3>2. Configure <code>build.zig</code></h3>
          <p>Import the Horizon module and link it into your executable:</p>
          <pre><code class="code-block">const horizon_dep = b.dependency("horizon", .{
    .target = target,
    .optimize = optimize,
});

const exe = b.addExecutable(.{
    .name = "app",
    .root_source_file = b.path("src/main.zig"),
    .target = target,
    .optimize = optimize,
});

exe.root_module.addImport("horizon", horizon_dep.module("horizon"));
b.installArtifact(exe);</code></pre>

          <h3>3. Install PCRE2</h3>
          <p>PCRE2 is required for regex routing:</p>
          <pre><code class="code-block"># Debian/Ubuntu
sudo apt-get install libpcre2-dev

# macOS (Homebrew)
brew install pcre2

# Dockerfile
RUN apt-get update &amp;&amp; apt-get install -y libpcre2-dev</code></pre>

          <h3 id="minimal-example">4. Minimal Horizon server</h3>
          <p>Here is a small but complete Horizon application:</p>
          <pre><code class="code-block">const std = @import("std");
const net = std.net;
const horizon = @import("horizon");

const Server = horizon.Server;
const Context = horizon.Context;
const Errors = horizon.Errors;

fn homeHandler(context: *Context) Errors.Horizon!void {
    try context.response.html("&lt;h1&gt;Hello Horizon!&lt;/h1&gt;");
}

fn apiHandler(context: *Context) Errors.Horizon!void {
    const name = context.request.getQuery("name") orelse "World";
    const json = try std.fmt.allocPrint(
        context.allocator,
        "{{\"message\":\"Hello, {s}!\"}}",
        .{ name },
    );
    defer context.allocator.free(json);
    try context.response.json(json);
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const address = try net.Address.resolveIp("0.0.0.0", 5000);
    var srv = Server.init(allocator, address);
    defer srv.deinit();

    try srv.router.get("/", homeHandler);
    try srv.router.get("/api/hello", apiHandler);

    // Optional: print the route table on startup
    // srv.show_routes_on_startup = true;

    std.debug.print("Server listening on http://0.0.0.0:5000\n", .{});
    try srv.listen();
}</code></pre>

          <p>
            Build and run your server with:
          </p>
          <pre><code class="code-block">zig build run</code></pre>
          <p>
            Then open <code>http://localhost:5000/</code> or
            <code>http://localhost:5000/api/hello?name=Zig</code>.
          </p>
        </section>

        <section id="routing" class="doc-section">
          <h2>Routing</h2>
          <p>
            Horizon’s router lets you define HTTP routes with method-aware matching, path parameters,
            and PCRE2-based constraints. Routes are attached to the server’s internal router.
          </p>

          <h3>Basic routes</h3>
          <pre><code class="code-block">try srv.router.get("/", homeHandler);
try srv.router.post("/users", createUserHandler);
try srv.router.put("/users/:id", updateUserHandler);
try srv.router.delete("/users/:id", deleteUserHandler);</code></pre>

          <h3>Path parameters</h3>
          <p>Use <code>:name</code> segments to capture parameters from the path:</p>
          <pre><code class="code-block">try srv.router.get("/users/:id", getUserHandler);

fn getUserHandler(context: *Context) Errors.Horizon!void {
    if (context.request.getParam("id")) |id| {
        try context.response.text(id);
    } else {
        context.response.setStatus(.bad_request);
        try context.response.json("{\"error\":\"ID not found\"}");
    }
}</code></pre>

          <h3>Regex-constrained parameters</h3>
          <p>Attach a PCRE2 pattern directly to the parameter:</p>
          <pre><code class="code-block">// Only numbers
try srv.router.get("/users/:id([0-9]+)", getUserHandler);

// Letters only
try srv.router.get("/category/:name([a-zA-Z]+)", getCategoryHandler);</code></pre>
          <p>If the pattern does not match, the request is treated as a 404.</p>

          <h3>Route groups with <code>mount</code></h3>
          <p>Group related routes under a common prefix:</p>
          <pre><code class="code-block">try srv.router.mount("/api", .{
    .{ "GET",  "/users", listUsers },
    .{ "POST", "/users", createUser },
    .{ "GET",  "/posts", listPosts },
});</code></pre>

          <h3>Mounting routes from modules</h3>
          <pre><code class="code-block">// routes/api.zig
const horizon = @import("horizon");
const Context = horizon.Context;
const Errors = horizon.Errors;

fn usersHandler(context: *Context) Errors.Horizon!void {
    try context.response.text("API: Users");
}

pub const routes = .{
    .{ "GET", "/users", usersHandler },
};</code></pre>

          <pre><code class="code-block">// main.zig
const api_routes = @import("routes/api.zig");
try srv.router.mount("/api", api_routes);</code></pre>

          <h3>Debugging routes</h3>
          <pre><code class="code-block">srv.show_routes_on_startup = true;
try srv.listen();

// or:
srv.router.printRoutes();</code></pre>
        </section>

        <section id="request-response" class="doc-section">
          <h2>Request &amp; Response</h2>
          <p>
            Each handler in Horizon receives a <code>*Context</code> which exposes a <code>Request</code> and a
            <code>Response</code> object. You use these to read request data and build responses.
          </p>

          <h3>Reading headers and query parameters</h3>
          <pre><code class="code-block">fn handler(context: *Context) Errors.Horizon!void {
    const method = context.request.method;
    const uri = context.request.uri;

    const auth = context.request.getHeader("Authorization") orelse "none";
    const page = context.request.getQuery("page") orelse "1";
    const limit = context.request.getQuery("limit") orelse "10";

    _ = method;
    _ = uri;
    _ = auth;
    _ = page;
    _ = limit;
}</code></pre>

          <h3>JSON, HTML, and text responses</h3>
          <pre><code class="code-block">try context.response.json("{\"message\":\"Hello\",\"status\":\"ok\"}");
// Content-Type: application/json

try context.response.html(
    \\&lt;!DOCTYPE html&gt;
    \\&lt;html&gt;
    \\&lt;head&gt;&lt;title&gt;Horizon&lt;/title&gt;&lt;/head&gt;
    \\&lt;body&gt;&lt;h1&gt;Hello from Horizon&lt;/h1&gt;&lt;/body&gt;
    \\&lt;/html&gt;
);
// Content-Type: text/html; charset=utf-8

try context.response.text("Hello, World!");
// Content-Type: text/plain; charset=utf-8</code></pre>

          <h3>Custom headers and status codes</h3>
          <pre><code class="code-block">context.response.setStatus(.created);
try context.response.setHeader("X-Request-Id", "12345");
try context.response.setHeader("Cache-Control", "no-store");
try context.response.text("Created");</code></pre>

          <h3>Streaming files</h3>
          <pre><code class="code-block">fn downloadHandler(context: *Context) Errors.Horizon!void {
    const file_path = "public/downloads/file.pdf";
    const file_stat = try std.fs.cwd().statFile(file_path);

    context.response.setStatus(.ok);
    try context.response.setHeader("Content-Type", "application/pdf");
    try context.response.setHeader(
        "Content-Disposition",
        "attachment; filename=\\"file.pdf\\"",
    );

    try context.response.streamFile(file_path, file_stat.size);
}</code></pre>
        </section>

        <section id="middleware" class="doc-section">
          <h2>Middleware</h2>
          <p>
            Middleware in Horizon forms a chain that wraps your handlers. Each middleware can inspect or modify
            the request/response and decide whether to continue the chain.
          </p>

          <h3>Global middleware</h3>
          <pre><code class="code-block">const LoggingMiddleware = horizon.LoggingMiddleware;
const CorsMiddleware = horizon.CorsMiddleware;

var srv = Server.init(allocator, address);
defer srv.deinit();

const logging = LoggingMiddleware.init();
try srv.router.middlewares.use(&logging);

const cors = CorsMiddleware.initWithConfig(.{
    .allow_origin = "*",
    .allow_methods = "GET, POST, PUT, DELETE, OPTIONS",
    .allow_headers = "Content-Type, Authorization",
});
try srv.router.middlewares.use(&cors);</code></pre>

          <h3>Route-specific middleware</h3>
          <pre><code class="code-block">const BearerAuth = horizon.BearerAuth;
const MiddlewareChain = horizon.Middleware.Chain;

var protected_middlewares = MiddlewareChain.init(allocator);
defer protected_middlewares.deinit();

const bearer_auth = BearerAuth.init("/api", "secret-token");
try protected_middlewares.use(&bearer_auth);

try srv.router.getWithMiddleware("/api/protected", protectedHandler, &protected_middlewares);</code></pre>

          <h3>Static file middleware</h3>
          <pre><code class="code-block">const StaticMiddleware = horizon.StaticMiddleware;

// Serve files from "./public" under "/static"
var static_mw = StaticMiddleware.init("public");
try srv.router.middlewares.use(&static_mw);</code></pre>

          <h3>Custom middleware</h3>
          <pre><code class="code-block">pub const CustomMiddleware = struct {
    const Self = @This();

    prefix: []const u8,
    enabled: bool,

    pub fn init(prefix: []const u8) Self {
        return .{ .prefix = prefix, .enabled = true };
    }

    pub fn middleware(
        self: *const Self,
        allocator: std.mem.Allocator,
        req: *horizon.Request,
        res: *horizon.Response,
        ctx: *horizon.Middleware.Context,
    ) horizon.Errors.Horizon!void {
        _ = allocator;
        if (self.enabled) {
            std.debug.print("{s}: {s}\n", .{ self.prefix, req.uri });
        }
        try ctx.next(allocator, req, res);
    }
};</code></pre>
        </section>

        <section id="sessions" class="doc-section">
          <h2>Sessions</h2>
          <p>
            Horizon’s session system lets you store per-user state on the server, identified by a secure
            cookie. You can choose between in-memory and Redis-backed storage.
          </p>

          <h3>Session middleware setup</h3>
          <pre><code class="code-block">const SessionStore = horizon.SessionStore;
const SessionMiddleware = horizon.SessionMiddleware;

var session_store = SessionStore.init(allocator);
defer session_store.deinit();

var srv = Server.init(allocator, address);
defer srv.deinit();

const session_middleware = SessionMiddleware.init(&session_store);
try srv.router.middlewares.use(&session_middleware);</code></pre>

          <h3>Using sessions in handlers</h3>
          <pre><code class="code-block">fn loginHandler(context: *Context) Errors.Horizon!void {
    if (SessionMiddleware.getSession(context.request)) |session| {
        try session.set("user_id", "123");
        try session.set("username", "alice");
        try session.set("logged_in", "true");
        try context.response.json("{\"status\":\"ok\",\"message\":\"Logged in\"}");
    } else {
        context.response.setStatus(.internal_server_error);
        try context.response.json("{\"error\":\"Failed to create session\"}");
    }
}</code></pre>

          <h3>Redis-backed sessions</h3>
          <pre><code class="code-block">const RedisBackend = horizon.RedisBackend;

var redis_backend = try RedisBackend.initWithConfig(allocator, .{
    .host = "127.0.0.1",
    .port = 6379,
    .prefix = "horizon:session:",
    .default_ttl = 3600,
});
defer redis_backend.deinit();

var session_store = SessionStore.initWithBackend(allocator, redis_backend.backend());
defer session_store.deinit();</code></pre>
        </section>

        <section id="templates" class="doc-section">
          <h2>Templates</h2>
          <p>
            Horizon integrates with ZTS (Zig Templates made Simple) to render HTML at compile time. Templates
            are section-based and typically stored under a <code>views/</code> directory.
          </p>

          <h3>Template sections</h3>
          <pre><code class="code-block">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
.header
&lt;header&gt;
  &lt;h1&gt;Welcome&lt;/h1&gt;
&lt;/header&gt;
.content
&lt;main&gt;
  &lt;p&gt;Main content here&lt;/p&gt;
&lt;/main&gt;
.footer
&lt;footer&gt;
  &lt;p&gt;&amp;copy; 2025&lt;/p&gt;
&lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

          <h3>Rendering templates</h3>
          <pre><code class="code-block">const welcome_template = @embedFile("views/welcome.html");

fn handleWelcome(context: *Context) Errors.Horizon!void {
    try context.response.renderHeader(welcome_template, .{"Welcome to Horizon!"});
}</code></pre>

          <h3>Concatenating sections</h3>
          <pre><code class="code-block">var renderer = try context.response.renderMultiple(welcome_template);
_ = try renderer.writeHeader(.{});
_ = try renderer.write("header", .{});
_ = try renderer.write("content", .{});
_ = try renderer.write("footer", .{});</code></pre>
        </section>

        <section id="api-reference" class="doc-section">
          <h2>High-level API Reference</h2>
          <p>
            This section summarizes the main types in Horizon. For deeper explanations and examples,
            refer to the dedicated guide sections above.
          </p>

          <h3>Server</h3>
          <ul>
            <li><strong>Fields</strong>: <code>allocator</code>, <code>router</code>, <code>address</code>, <code>show_routes_on_startup</code>, <code>max_threads</code>.</li>
            <li><strong>Key methods</strong>: <code>init</code>, <code>deinit</code>, <code>listen</code>.</li>
          </ul>

          <h3>Router</h3>
          <ul>
            <li><strong>Key methods</strong>: <code>get</code>, <code>post</code>, <code>put</code>, <code>delete</code>, <code>mount</code>, <code>mountWithMiddleware</code>, <code>printRoutes</code>.</li>
          </ul>

          <h3>Context</h3>
          <p>
            Bundles together the allocator, request, response, router, and server for each handler:
          </p>
          <pre><code class="code-block">pub const Context = struct {
    allocator: std.mem.Allocator,
    request: *Request,
    response: *Response,
    router: *Router,
    server: *Server,
};</code></pre>

          <h3>Request &amp; Response</h3>
          <ul>
            <li><strong>Request</strong>: methods like <code>getHeader</code>, <code>getQuery</code>, <code>getParam</code>.</li>
            <li><strong>Response</strong>: methods like <code>setStatus</code>, <code>setHeader</code>, <code>json</code>, <code>html</code>, <code>text</code>, <code>streamFile</code>.</li>
          </ul>

          <h3>Sessions &amp; Middleware</h3>
          <ul>
            <li><strong>Session</strong>: <code>set</code>, <code>get</code>, <code>remove</code>, <code>isValid</code>, <code>setExpires</code>.</li>
            <li><strong>SessionStore</strong>: <code>create</code>, <code>get</code>, <code>remove</code>, <code>cleanup</code>.</li>
            <li><strong>SessionMiddleware</strong>: attaches sessions to requests via cookies.</li>
            <li><strong>MiddlewareChain</strong>: manages the execution of middleware in order.</li>
          </ul>
        </section>

        <section id="project-structure" class="doc-section">
          <h2>Project Structure</h2>
          <p>The Horizon repository itself is organized as follows:</p>
          <pre><code class="code-block">horizon/
├── src/
│   ├── horizon.zig           # Main module export
│   └── horizon/
│       ├── server.zig        # HTTP server
│       ├── router.zig        # Router
│       ├── request.zig       # Request handling
│       ├── response.zig      # Response handling
│       ├── context.zig       # Unified context
│       ├── middleware.zig    # Middleware chain
│       ├── middlewares/      # Built-in middlewares
│       └── utils/            # Utilities (errors, pcre2, redis client)
├── tests/                    # Test suite
└── documents/                # User documentation (this guide is based on it)</code></pre>
        </section>

        <section id="testing" class="doc-section">
          <h2>Testing</h2>
          <p>
            Horizon ships with a comprehensive test suite. You can run it using the provided <code>Makefile</code>:
          </p>
          <pre><code class="code-block"># Run all tests
make zig build test

# Run tests with filter
make zig build test -- --test-filter router</code></pre>
        </section>

        <section id="sample-app" class="doc-section">
          <h2>Sample Application: <code>horizon_sample</code></h2>
          <p>
            The <code>horizon_sample</code> repository demonstrates how to structure a real-world Horizon
            application, including a Zig backend, React-based frontend, and Dockerized infrastructure.
          </p>

          <h3>Quick start</h3>
          <pre><code class="code-block">make up
# Application will be available at http://localhost:5000/</code></pre>

          <h3>Sample project layout</h3>
          <pre><code class="code-block">horizon_sample/
├── src/
│   ├── main.zig         # Application entry point
│   ├── root.zig         # Root module wiring
│   ├── libs/            # Shared libraries (e.g., DB helper)
│   ├── models/          # Domain models
│   ├── routes/          # Route handlers (admin, index, etc.)
│   └── views/           # ZTS templates
├── frontend/            # Sample React frontend
├── static/              # Raw static files served by Horizon
├── infra/               # Docker files for app, cache (Redis), and DB
└── build.zig            # Zig build configuration</code></pre>

          <p>
            Use this sample as a reference when designing your own Horizon-based applications:
            separate routes into modules, keep templates in <code>views/</code>, and rely on middleware
            for cross-cutting concerns like logging, CORS, auth, and sessions.
          </p>
        </section>
      </main>
    </div>

    <footer class="site-footer">
      <div class="site-footer-inner">
        <span>&copy; 2025 Horizon. Built with Zig.</span>
        <a href="https://github.com/HARMONICOM/horizon" target="_blank" rel="noreferrer">GitHub</a>
      </div>
    </footer>
  </div>
</body>
</html>


